{"name":"Wheeloffortune","tagline":"cs5600 Project and site","body":"# Wheel Of Fortune AI\r\n\r\n## Introduction\r\n\r\nThe best way of measuring progress of a machine is by looking back over previous iterations. As you push to place more data into a machine, it makes the machine better fit to compete against a human opponent. By using this, I can compare the progress the machine's brain is making, and cause it to make better decisions versus an opponent.\r\n\r\n## Description\r\n\r\nThis project runs the game \"Wheel of Fortune\" for a human to play against. It has the ability to pit other AI against itself as well. By making each iteration just a bit better than the last, I can compare the abilities of each machine stage. \r\n\r\n## What is wheel of fortune?\r\n\r\nWheel of fortune is a game-show where players try to guess a word or phrase using letters they have bought from the money they have accrued. A player takes a turn by guessing a letter and if that letter exists on the board, then it is placed and is visible to all. The game show takes into account how much money a player has, and if they have enough, they can purchase a vowel and use that in their guess. The game show also gives the players a theme to help them give a better guess on what the answer might be. \r\n\r\nAn example of a single phrase playthrough on the show is found below:\r\n\r\n[Video of show](https://www.youtube.com/watch?v=oEyBg-1-iV4&feature=youtu.be&t=207)\r\n\r\n## Description Continued\r\n\r\nMy version of the game is a bit different than the show because of what I am trying to test. I've taken out the cash bank, the wheel and the theme associated with the phrase. I've also changed the rules so that when a machine has guessed, it is then the next machine's or the player's turn. The decision behind this is to better encapsulate the CPU time a machine in the game takes to guess a good letter or the phrase itself. If I were to include these, then it wouldn't give as good of a test case.\r\n\r\nI've found a few helpful databases online to give the machines a list of words to choose from. These will in turn help the database choose a phrase to match in the spaces given. Depending on how well the sentence fits, the second iteration and beyond will be able to make an educated guess on what it might be.\r\n\r\nThe project is setup through 4 iterations, with each iteration being a bit smarter than the last.\r\n\r\n1. A basic “Spin to win” approach (including a dictionary)\r\n2. “Spin to win” plus a database of commonly used words\r\n3. Add a database of common phrases, and use those phrases to guess\r\n4. Implement a best letter choice that will use shannon entropy\r\n\r\nWhen the project is finished, you should be able to choose what opponents you want to play against, and possibly how many of each. \r\n\r\nI am hoping that in the end, the third and fourth iterations will be almost impossible to beat. I am also hoping to achieve a manageable CPU time for both of the latter iterations.\r\n\r\n# Teaser\r\n\r\nThis shows how the GUI works with the machine. \r\n<img src=http://i.imgur.com/TGeDAKD.png>\r\nAs you choose letters, they are no longer accessible to any other players.\r\n<img src=http://i.imgur.com/lUxHDOx.png>\r\n\r\nAdding a sleep timer makes the game more realistic to the human player, and also makes it easier for them to observe the others. \r\n<img src=http://i.imgur.com/BiEsnK3.png>\r\n\r\n## Example gifs and videos\r\n\r\nUsing the Keyboard\r\n[Full Video](https://www.youtube.com/watch?v=BSpcmmV9eng)\r\nGuessing a phrase\r\n[Full Video](https://www.youtube.com/watch?v=mFh9LPx19dA&feature=youtu.be)\r\nMachine guessing for win\r\n[Full Video](https://www.youtube.com/watch?v=FSMuxJX_p7U)\r\n\r\n## Testing\r\n\r\nThe tests came out almost as I would have suspected. The goal of the project was to try to build a set of machines, one better than the next. The first three machines were more efficient than the next, but the fourth used a lot more cpu time than the rest.\r\n\r\nAll CPU Time Info\r\n<img src=http://i.imgur.com/pQ49GBJ.png>\r\n\r\n\r\n## Graphs of CPU over timer\r\n###First Iteration\r\n\r\nThis graph really shows just how simple this machine was. The only work really being done by the player is a check to see if the phrase was finished, and to iterate to the next letter in the sequence. Somehow though, this equated to more cpu time than the second and third iterations.\r\n<img src=http://i.imgur.com/X7bGzIJ.png>\r\n\r\n###Second Iteration\r\n\r\nThis iteration has a few more checks in place while it goes through the letter choices. It looks to make sure that letter has not been chosen already, and checks to see if the phrase is finished, all while going through the alphabet making correct choices. This shows a bit of learning in the fact that it has the checks in place to make sure that it never chooses poorly. If it were to only go through the alphabet, and not check to make sure that letter wasn't already chosen, it would get nowhere. \r\n\r\nThe way that it makes this check, is by having access to the letter bank that all machines, excluding the first iteration, can utilize. It makes its way through and has the ability to check if that letter is still present in the list, if it is, then it is a viable letter in this machine's eyes. No further checks on the alphabet are made by this machine. \r\n\r\nThis machine also uses slightly less CPU time than the first iteration. Looking at the data, and knowing the code, this is because the machine has to deal with less data, and uses built in functions in c# to check to see if the letter is present in the list.\r\n<img src=http://i.imgur.com/aO2xo7n.png>\r\n\r\n###Third Iteration\r\n\r\nThis machine adds upon the second iteration. It does the same letter check to make sure it is not choosing a bad letter, and then adds upon the last by seeing if it has enough of the phrase done to allow a guess to be placed. \r\n\r\nThe list of phrases is read in by the program at the beginning. This list of phrases afterwards is utilized by iterations 3 and 4. During iteration 3's turn, it will use a function to determine if a guess is allowed. (I've set the threshold to be 80%, which means that 80% of the letters in a phrase need to be filled in order for this iteration to be allowed to make a guess.) If the threshold is reached, the machine will take all phrases in the database that are of that length and put them into a queue to be matched. This queue uses the letters already guessed and filled in via the \"brain\", to search the phrases in the queue letter by letter in order to try to guess the correct phrase. I had to set the threshold to 80% because through experience playing against this machine, it was quite unfair. I originally had the threshold set to about 25% and the machine would finish before the second turn was even placed. I even added more phrases to the list, but even this did not help. No phrase was ambiguous enough that the machine would not know exactly the right phrase to guess. \r\n\r\nI feel that in terms of difficulty playing against, that this machine is the hardest one to beat. Because of its order in the queue, it always beats the last. It is not too difficult to beat via a person, depending on the threshold. But it will even beat the last iteration 90% of the time.\r\n<img src=http://i.imgur.com/sSfdCOL.png>\r\n\r\n###Fourth Iteration\r\n\r\nThe last iteration actually uses the most CPU time out of all the others. This is because it uses Shannon entropy to always guess the best letter possible for the phrase. \r\n\r\n(Formula for Shannon entropy with x being yes counter and z being no counter)\r\n###[(x/y)log2(x/y) + (z/y)log2(z/y)]\r\n\r\nEssentially how this works is through a series of filters. The first filter will take the length of the phrase in its entirety, and filter the list of all phrases down to only phrases of that length. If only one phrase is found of that length, it will guess that phrase and win the game. However, this is not usually the case. After this first filter has been placed, the machine utilizes the remaining letters list. In this section, the machine will go through each of the phrases and find the most common letter in all the phrases combined. If the letter is present in a phrase, then a tally will be added to the yes counter. If the letter is not present, it will then add a tally to the no counter. Using these two counters, the machine can find the best change possible. What is looking for is the closest to 50/50 possible. Whichever letter ends up being closest to this will end up being the letter chosen. \r\n\r\nAfter the letter guess is made, the machine will remove this letter from the list. The next time around, all phrases that are of the same length, and that contain the already guessed letters will be the only phrases taken into account moving forward. \r\n\r\n(Visual guide to Shannon entropy for this case)\r\n<img src=http://imgur.com/ELDSW3q.png>\r\n\r\nThe reason this machine doesn't always win is because there are a few instances where the letters in a phrase are pretty ambiguous, so the machine has to go through a few iterations to deter itself from using that phrase. But by the time that happens, iteration 3 has already won so this 4th iteration does not stand a chance.\r\n\r\n<img src=http://i.imgur.com/ZzgAPgc.png>\r\n\r\nLooking over these graphs, the last iteration seems to average out to the rest of the machines, but stays more constantly high than the others. This is because it has to keep a lot more data at once than the others. \r\n\r\nOverall this was a success. But the third machine wins more constantly than the others. If the fourth iteration was placed before the third in the turn order it still might not win. It really depends on what order the players take their turn in.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}